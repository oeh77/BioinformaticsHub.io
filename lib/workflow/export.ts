/**
 * Workflow Export Utilities
 * 
 * Generate workflow files in CWL, Nextflow, and Snakemake formats
 */

import { Node, Edge } from "reactflow";

interface WorkflowNode extends Node {
  data: {
    name?: string;
    slug?: string;
    label?: string;
    type?: string;
    description?: string;
    category?: string;
  };
}

interface ExportOptions {
  name: string;
  description?: string;
  version?: string;
  author?: string;
}

/**
 * Generate CWL (Common Workflow Language) workflow
 */
export function generateCWL(
  nodes: WorkflowNode[],
  edges: Edge[],
  options: ExportOptions
): string {
  const toolNodes = nodes.filter(n => n.type === "tool");
  const inputNodes = nodes.filter(n => n.type === "input");
  const outputNodes = nodes.filter(n => n.type === "output");

  // Build inputs
  const inputs: Record<string, unknown> = {};
  inputNodes.forEach((node, idx) => {
    inputs[`input_${idx + 1}`] = {
      type: "File",
      doc: node.data.label || `Input file ${idx + 1}`,
    };
  });

  // Build outputs
  const outputs: Record<string, unknown> = {};
  outputNodes.forEach((node, idx) => {
    // Find connected step
    const incomingEdge = edges.find(e => e.target === node.id);
    const sourceNode = incomingEdge 
      ? nodes.find(n => n.id === incomingEdge.source) 
      : null;
    
    outputs[`output_${idx + 1}`] = {
      type: "File",
      doc: node.data.label || `Output file ${idx + 1}`,
      outputSource: sourceNode ? `${sourceNode.id}/output` : undefined,
    };
  });

  // Build steps
  const steps: Record<string, unknown> = {};
  toolNodes.forEach((node) => {
    const incomingEdges = edges.filter(e => e.target === node.id);
    const inputs: Record<string, string> = {};
    
    incomingEdges.forEach((edge, idx) => {
      const sourceNode = nodes.find(n => n.id === edge.source);
      if (sourceNode?.type === "input") {
        const inputIdx = inputNodes.findIndex(n => n.id === sourceNode.id);
        inputs[`input_${idx + 1}`] = `input_${inputIdx + 1}`;
      } else if (sourceNode?.type === "tool") {
        inputs[`input_${idx + 1}`] = `${sourceNode.id}/output`;
      }
    });

    steps[node.id] = {
      run: node.data.slug ? `tools/${node.data.slug}.cwl` : `tools/${node.id}.cwl`,
      in: inputs,
      out: ["output"],
      doc: node.data.description || node.data.name,
    };
  });

  const cwlWorkflow = {
    cwlVersion: "v1.2",
    class: "Workflow",
    label: options.name,
    doc: options.description || `Generated workflow: ${options.name}`,
    
    requirements: {
      SubworkflowFeatureRequirement: {},
      ScatterFeatureRequirement: {},
      MultipleInputFeatureRequirement: {},
    },
    
    inputs,
    outputs,
    steps,
  };

  return `#!/usr/bin/env cwl-runner
# ${options.name}
# Generated by BioinformaticsHub.io Workflow Builder
# Version: ${options.version || "1.0.0"}
# Author: ${options.author || "BioinformaticsHub.io"}

${JSON.stringify(cwlWorkflow, null, 2).replace(/"([^"]+)":/g, "$1:")}
`;
}

/**
 * Generate Nextflow workflow
 */
export function generateNextflow(
  nodes: WorkflowNode[],
  edges: Edge[],
  options: ExportOptions
): string {
  const toolNodes = nodes.filter(n => n.type === "tool");
  const inputNodes = nodes.filter(n => n.type === "input");
  
  // Generate process definitions
  const processes = toolNodes.map((node) => {
    const incomingEdges = edges.filter(e => e.target === node.id);
    const inputs = incomingEdges.map((edge, idx) => {
      const sourceNode = nodes.find(n => n.id === edge.source);
      if (sourceNode?.type === "input") {
        return `    path input_${idx + 1}`;
      }
      return `    path input_${idx + 1}`;
    });

    const processId = node.data.slug || node.id.replace(/-/g, "_");
    
    return `
process ${processId} {
    tag "${node.data.name || processId}"
    
    input:
${inputs.join("\n") || "    val ready"}

    output:
    path "output/*", emit: results

    script:
    """
    # ${node.data.description || `Run ${node.data.name}`}
    # Add your ${node.data.name} command here
    mkdir -p output
    echo "Running ${node.data.name}..." > output/log.txt
    """
}`;
  });

  // Generate workflow connections
  const workflowBody = toolNodes.map((node) => {
    const incomingEdges = edges.filter(e => e.target === node.id);
    const processId = node.data.slug || node.id.replace(/-/g, "_");
    
    if (incomingEdges.length === 0) {
      return `    ${processId}(input_ch)`;
    }
    
    const sources = incomingEdges.map(edge => {
      const sourceNode = nodes.find(n => n.id === edge.source);
      if (sourceNode?.type === "tool") {
        const sourceProcessId = sourceNode.data.slug || sourceNode.id.replace(/-/g, "_");
        return `${sourceProcessId}.out.results`;
      }
      return "input_ch";
    });
    
    return `    ${processId}(${sources.join(", ")})`;
  });

  // Generate input channel
  const inputDefs = inputNodes.map((node, idx) => 
    `params.input_${idx + 1} = "${node.data.label || `input_${idx + 1}`}"`
  );

  return `#!/usr/bin/env nextflow
/*
 * ${options.name}
 * Generated by BioinformaticsHub.io Workflow Builder
 * Version: ${options.version || "1.0.0"}
 * Author: ${options.author || "BioinformaticsHub.io"}
 * 
 * ${options.description || ""}
 */

nextflow.enable.dsl = 2

// Parameters
${inputDefs.join("\n") || 'params.input = "input/*"'}

// Input channel
input_ch = Channel.fromPath(params.input_1 ?: params.input)

${processes.join("\n")}

// Main workflow
workflow {
    log.info """
    =========================================
    ${options.name}
    =========================================
    """
    
${workflowBody.join("\n") || "    // Add workflow steps"}
}

workflow.onComplete {
    log.info "Pipeline completed at: \$workflow.complete"
    log.info "Execution status: \${ workflow.success ? 'OK' : 'failed' }"
}
`;
}

/**
 * Generate Snakemake workflow
 */
export function generateSnakemake(
  nodes: WorkflowNode[],
  edges: Edge[],
  options: ExportOptions
): string {
  const toolNodes = nodes.filter(n => n.type === "tool");
  const inputNodes = nodes.filter(n => n.type === "input");
  const outputNodes = nodes.filter(n => n.type === "output");
  
  // Build dependency graph
  const getOutputFor = (nodeId: string): string => {
    const node = nodes.find(n => n.id === nodeId);
    if (node?.type === "input") {
      return `config["input_files"]`;
    }
    const ruleName = node?.data.slug || nodeId.replace(/-/g, "_");
    return `rules.${ruleName}.output`;
  };

  // Generate rules
  const rules = toolNodes.map((node) => {
    const incomingEdges = edges.filter(e => e.target === node.id);
    const ruleName = node.data.slug || node.id.replace(/-/g, "_");
    
    const inputs = incomingEdges.map((edge, idx) => {
      const sourceNode = nodes.find(n => n.id === edge.source);
      if (sourceNode?.type === "input") {
        return `        input_${idx + 1}=config["input_files"]`;
      }
      const sourceRuleName = sourceNode?.data.slug || sourceNode?.id.replace(/-/g, "_");
      return `        input_${idx + 1}=rules.${sourceRuleName}.output`;
    });

    return `
rule ${ruleName}:
    """${node.data.description || node.data.name}"""
    input:
${inputs.join(",\n") || "        # No input dependencies"}
    output:
        "results/${ruleName}/output.txt"
    log:
        "logs/${ruleName}.log"
    threads: 4
    shell:
        """
        # ${node.data.name}
        mkdir -p results/${ruleName}
        echo "Running ${node.data.name}..." > {output} 2> {log}
        """`;
  });

  // Generate final outputs for 'all' rule
  const finalOutputs = outputNodes.length > 0
    ? outputNodes.map((node) => {
        const incomingEdge = edges.find(e => e.target === node.id);
        if (incomingEdge) {
          const sourceNode = nodes.find(n => n.id === incomingEdge.source);
          const ruleName = sourceNode?.data.slug || sourceNode?.id.replace(/-/g, "_");
          return `        "results/${ruleName}/output.txt"`;
        }
        return "";
      }).filter(Boolean)
    : toolNodes.map(node => {
        const ruleName = node.data.slug || node.id.replace(/-/g, "_");
        return `        "results/${ruleName}/output.txt"`;
      });

  return `# ${options.name}
# Generated by BioinformaticsHub.io Workflow Builder
# Version: ${options.version || "1.0.0"}
# Author: ${options.author || "BioinformaticsHub.io"}
#
# ${options.description || ""}
#
# Usage: snakemake --cores 4

configfile: "config.yaml"

# Define final output files
rule all:
    input:
${finalOutputs.join(",\n") || '        "results/final_output.txt"'}

${rules.join("\n")}

# Configuration template (save as config.yaml):
# input_files:
#   - "data/sample1.fastq"
#   - "data/sample2.fastq"
`;
}

/**
 * Export workflow to specified format
 */
export function exportWorkflow(
  format: "cwl" | "nextflow" | "snakemake",
  nodes: WorkflowNode[],
  edges: Edge[],
  options: ExportOptions
): { content: string; filename: string; mimeType: string } {
  switch (format) {
    case "cwl":
      return {
        content: generateCWL(nodes, edges, options),
        filename: `${options.name.toLowerCase().replace(/\s+/g, "_")}.cwl`,
        mimeType: "application/x-yaml",
      };
    case "nextflow":
      return {
        content: generateNextflow(nodes, edges, options),
        filename: `${options.name.toLowerCase().replace(/\s+/g, "_")}.nf`,
        mimeType: "text/plain",
      };
    case "snakemake":
      return {
        content: generateSnakemake(nodes, edges, options),
        filename: "Snakefile",
        mimeType: "text/plain",
      };
  }
}
